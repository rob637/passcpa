/**
 * CPA Question Normalization Script
 * Reorganizes all CPA questions into section-specific batch files
 * 
 * Target structure:
 * src/data/cpa/questions/
 * ├── far/
 * │   ├── batch1.ts, batch2.ts, ...
 * │   └── index.ts
 * ├── aud/
 * ├── reg/
 * ├── bar/
 * ├── isc/
 * ├── tcp/
 * └── index.ts
 * 
 * Run with: node scripts/normalize-cpa-questions.cjs --dry-run
 *          node scripts/normalize-cpa-questions.cjs --execute
 */

const fs = require('fs');
const path = require('path');

const QUESTIONS_DIR = 'src/data/cpa/questions';
const BATCH_SIZE = 50; // Questions per batch file
const SECTIONS = ['FAR', 'AUD', 'REG', 'BAR', 'ISC', 'TCP'];

// Extract questions from a TypeScript file
function extractQuestions(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  const questions = [];
  
  // Match each question object (simplified regex - handles most cases)
  const questionBlocks = content.split(/\n  \{[\s]*\n/).slice(1);
  
  for (const block of questionBlocks) {
    // Extract key fields
    const idMatch = block.match(/id:\s*['"]([^'"]+)['"]/);
    const sectionMatch = block.match(/section:\s*['"]([^'"]+)['"]/);
    
    if (idMatch && sectionMatch) {
      // Find the full question block
      const fullBlock = '  {\n' + block.split(/\n  \},?\s*(?:\n  \{|$)/)[0] + '\n  }';
      questions.push({
        id: idMatch[1],
        section: sectionMatch[1],
        content: fullBlock.trim()
      });
    }
  }
  
  return questions;
}

// Group questions by section
function groupBySection(questions) {
  const grouped = {};
  for (const section of SECTIONS) {
    grouped[section] = [];
  }
  
  for (const q of questions) {
    if (grouped[q.section]) {
      grouped[q.section].push(q);
    }
  }
  
  return grouped;
}

// Generate batch file content
function generateBatchFile(section, questions, batchNum) {
  const exportName = `${section}_QUESTIONS_BATCH${batchNum}`;
  
  const content = `/**
 * CPA ${section} Questions - Batch ${batchNum}
 * ${questions.length} questions
 * Auto-generated by normalize-cpa-questions.cjs
 */

import { Question } from '../../../../types';

export const ${exportName}: Question[] = [
${questions.map(q => q.content).join(',\n')}
];
`;
  
  return { exportName, content };
}

// Main execution
const dryRun = process.argv.includes('--dry-run');
const execute = process.argv.includes('--execute');

if (!dryRun && !execute) {
  console.log('Usage: node scripts/normalize-cpa-questions.cjs [--dry-run | --execute]');
  process.exit(1);
}

console.log(`Mode: ${dryRun ? 'DRY RUN' : 'EXECUTE'}\n`);

// Collect all questions from existing files
const allFiles = fs.readdirSync(QUESTIONS_DIR)
  .filter(f => f.endsWith('.ts') && f !== 'index.ts');

let allQuestions = [];
console.log(`Processing ${allFiles.length} question files...\n`);

for (const file of allFiles) {
  const filePath = path.join(QUESTIONS_DIR, file);
  const questions = extractQuestions(filePath);
  console.log(`  ${file}: ${questions.length} questions`);
  allQuestions = allQuestions.concat(questions);
}

console.log(`\nTotal questions extracted: ${allQuestions.length}`);

// Group by section
const grouped = groupBySection(allQuestions);
console.log('\nQuestions by section:');
for (const [section, questions] of Object.entries(grouped)) {
  console.log(`  ${section}: ${questions.length}`);
}

if (dryRun) {
  console.log('\n[DRY RUN] Would create the following structure:');
  for (const [section, questions] of Object.entries(grouped)) {
    if (questions.length === 0) continue;
    const numBatches = Math.ceil(questions.length / BATCH_SIZE);
    console.log(`  ${section.toLowerCase()}/`);
    for (let i = 1; i <= numBatches; i++) {
      console.log(`    batch${i}.ts`);
    }
    console.log(`    index.ts`);
  }
  console.log('\nRun with --execute to apply changes.');
}
